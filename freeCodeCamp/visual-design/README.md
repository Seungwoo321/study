## 웹 개발에서의 시각디자인
웹 개발의 시각 디자인은 광범위한 주제입니다. 타이포그래피, 색상 이론, 그래픽, 애니메이션 및 페이지 레이아웃을 결합하여 사이트의 메시지 전달을 돕습니다. 좋은 디자인의 정의는 주제에 관한 많은 책을 가지고 잘 논의 된 주제 입니다.

기존적으로 대부분의 웹 컨텐츠는 사용자에게 정보를 제공합니다. 페이지의 시각적 디자인은 프레젠테이션 및 사용자 경험에 영향을 줄 수 있습니다. 웹 개발에서 HTML은 페이지 내용에 구조와 의미를 제공하고 CSS는 레이아웃과 모양을 제어합니다.

이 섹션에서는 개발자가 자신의 시각적 디자인을 만드는데 사용하지 몇 가지 기본 도구에 대해 설명합니다. 


## text-align 속성을 사용하여 텍스트 정렬
* 텍스트는 웹 컨텐츠의 큰 부분입니다. CSS에는 `text-alighn` 속성과 정렬하는 방법에 대한 몇 가지 옵션이 있습니다. 
* `text-aligh: justify;` 마지막 줄을 제외한 모든 텍스트 줄이 줄 상자의 왼쪽 및 오른쪽 가장자리와 만나도록 합니다.
* `text-aligh: center;` 텍스트를 중앙 정렬 
* `text-align: right;` 텍스트를 오른쪽 정렬
* `text-align: left;`텍스트를 왼쪽 정렬(기본값)

## width 속성을 사용하여 요소의 너비 조정

## height 속성을 사용하여 요소의 높이 조정

## strong 태그를 사용하여 텍스트를 굵게 표시
* 텍스트에 주의를 끌고 중요한 것을 상징하는데 종종 사용된다.
* strong 태그를 사용하면 브라우저는 요소에 `font-weight: bold;` CSS를 적용한다.

## u 태그를 사용하여 텍스트에 밑줄을 긋기
* 텍스트 섹션이 중요하거나 기억해야 할 것을 나타나는데 종종 사용된다.
* u 태그를 사용하면 브라우저는 요소에 `text-decoration: underline;` CSS를 적용한다.

## em 태그를 사용하여 텍스트를 기울임 꼴로 표시
* 텍스트를 강조하기 위해 em 태그를 사용 할 수 있다.
* em 태그를 사용하면 브라우저는 요소에 `text-style: italic;` CSS를 적용한다.

## s 태그를 사용하여 텍스트에 취소선 적용
* 텍스트 섹션이 더 이상 유효하지 않음을 나타낸다.
* s 태그를 사용하면 브라우저는 요소에 `text-decoration: line-through;` CSS를 적용한다.

## hr 요소를 사용하여 수평선 만들기
* hr 태그를 사용하여 포함하는 요소의 너비에 가로 선을 추가 할 수 있다.
* 주제의 변경을 정의하거나 컨텐츠 그룹을 시각적으로 분리하는데 사용 할 수 있다.

## 텍스트의 background-color 속성 조정
* 전경을 쉽게 읽을 수 있도록 전체 배경이나 텍스트 색상을 조정하는 대신 강조하려는 텍스트가 있는 요소에 배경색을 추가 할 수 있다.

## 단락 태그와 헤더의 크기 조정
* 헤더 태그(h1 ~ h6)의 글꼴 크기는 일반적으로 단락 태그의 글꼴 크기보다 커야한다.
* 이를 통해 사용자는 페이지에 있는 모든 것의 레이아웃과 중요도를 시각적으로 쉽게 이해 할 수 있다.
* `font-size` 속성을 사용하여 요소의 텍스트 크기를 조정한다.

## 카드 같은 요소에 box-shadow 추가
* `box-shodow` 속성은 요소에 하나 이상의 그림자를 적용한다.
* `offset-x`: 요소에서 수평으로 그림자를 얼마나 멀리 밀었는지
* `offset-y`: 요소에서 수직으로 그림자를 얼마나 멀리 밀었는지
* `blur-raduis`: 흐림반경, 선택사항 
* `spread-raduis`: 확산반경, 선택사항
* 각 상자 그림자 요소의 속성을 구분하기 위해 쉼표를 사용하여 여러 상자 그림자를 만들 수 있다.
* 다음은 주로 투명한 검은 색으로 약간의 그림자로 여러 그림자를 만드는 CSS 예이다.
```css
box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
```

## 요소의 불투명도 감소
* `opacity` 속성은 항목의 불투명도 또는 반대로 투명도를 조정하는데 사용된다.
    * 값 1은 불투명
    * 값 0.5는 반투명
    * 값 0은 완전 투명 
* 주어진 값은 이미지나 텍스트 블록의 전경색 배경색 투명도를 가진 전체 요소에 적용된다.

## text-transform 속성을 사용한 텍스트 대문자 만들기
* `text-transform` 속성은 텍스트 모양을 변경하는데 사용된다.
* 실제 HTML요소의 텍스트 내용을 변경하지 않고도 웹 페이지의 텍스트가 일관되게 표시할 수 있다.

Value | Result
------|---------
`lowercase` | "transform me"
`uppercase` | "TRANSFORM ME"
`capitalize` | "Transfrom Me"
`initial` | Use the default value
`inherit` | Use the `text-transform` value from the parent element
`none` | __Default__: Use the original text


## 여러 제목 요소의 글꼴 크기 설정
* `font-size` 속성은 주어진 요소에서 텍스트의 크기를 지정하는데 사용된다.
* 이 규칙을 여러 요소에 사용하여 페이지에서 텍스트의 시각적 일관성을 만들 수 있다.
* 예를 들어 제목 크기의 균형 맞추기 위해 h1 ~ h6 태그의 값을 설정 한다.

## 여러 제목 요소의 대한 글꼴 가중치 설정
* `font-weight` 속성은 텍스트 섹션에서 문자의 두께를 설정한다.

```html
<style>
  h1 {
    font-size: 68px;
    font-weight: 800;
  }
  h2 {
    font-size: 52px;
    font-weight: 600;
  }
  h3 {
    font-size: 40px;
    font-weight: 500;
  }
  h4 {
    font-size: 32px;
    font-weight: 400;
  }
  h5 {
    font-size: 21px;
    font-weight: 300;
  }
  h6 {
    font-size: 14px;
    font-weight: 200;
  }
</style>
<h1>This is h1 text</h1>
<h2>This is h2 text</h2>
<h3>This is h3 text</h3>
<h4>This is h4 text</h4>
<h5>This is h5 text</h5>
<h6>This is h6 text</h6>
```

## 단락 텍스트의 글꼴 크기 설정
* css의 `font-size` 속성은 제목으로 제한되지 않으며 텍스트를 포함하는 모든 요소에 적용 할 수 있다.

## 단락의 줄 높이 설정
* css는 `line-height` 속성을 제공하여 텍스트 블록에서 각 줄의 높이를 변경한다.
* 이름에서 알 수 있듯이 각 텍스트 줄에 표시되는 세로 공간의 양이 변경된다.

## 앵커 태그의 호버 상태 조정
* 앵커 태그의 스타일은 `:hover` 유사 클래스 선택기를 사용하여 호버 상태에 맞게 변경 할 수 있다.

## 요소의 상대 위치 변경
* CSS는 각 HTML 요소를 자체 상자로 취급하며, 일반적으로 CSS 상자 모델이라고 한다.
* 블록 수준 항목은 자동으로 새 줄 (제목, 단락 및 div) 에서 시작하는 반면 인라인 항목은 주변 내용 (예: 이미지 또는 범위) 내에 있다.
* 이런 방식으로 요소의 기본 레이아웃을 문서의 일반적인 흐름이라고 하지만 CSS는 `position` 속성을 제공하여 이를 재정의 한다.
* 요소의 `position`을 `relative` 로 설정하면 페이지의 일반적인 흐름에서 CSS가 현재 위치를 기준으로 요소를 이동시키는 방법을 지정 할 수 있다.
* left, right, top, bottom 의 CSS offset 속성과 쌍을 이룬다. 항목이 보통 위치에서 멀어지도록 픽셀, 백분율 또는 em 을 설정한다. 

## CSS 오프셋을 사용하여 상대적으로 배치된 요소 이동
* 상단 또는 하단, 왼쪽 또는 오른쪽의 CSS 오프셋은 문서의 일반적인 흐름에서 위치를 기준으로 항목을 오프셋 할 거리를 브라우저에 알려준다.
* 주어진 지점에서 요소를 멀리 오프셋하여 요소를 참조된 면에서 멀어지게 이동시킨다.

## 절대 위치로 요소를 부모에 고정
* `position` 속성에 대한 `absolute` 옵션은 부모 컨테이너를 기준으로 요소를 고정 시킨다.
* `relative` 와 달리 문서의 일반적인 흐름에서 요소를 제거 하므로 주변 항목은 무시한다.
* CSS 오프셋 속성은 위치를 조정하는데 사용된다.
* 한 가지 미묘한 차이는 가장 가까운 위치의 부모에 대해 잠기게 된다. 
* 상위 항목에 `position` 규칙을 추가하는 것을 잊어버린 경우(일반적으로 postion: relative;를 사용하여 수행) 브라우저는 체인을 계속 찾고 궁극적으로 body 태그를 기본값으로 사용한다. 

## 고정 위치로 요소를 브라우저 창에 고정
* `fixed` 옵션은 브라우저 창을 기준으로 요소를 잠그는 절대 위치 유형이다.
* 절대 위치와 마찬가지로 CSS 오프셋 속성과 함께 사용되며 문서의 일반적인 흐름에서 요소를 제거한다.
* 다른 항목은 더 이상 위치에 실현 되지 않으므로 다른 곳에서 일부 레이아웃 조정이 필요할 수 있다.
* 고정 위치와 절대 위치의 한 가지 주요 차이점은 사용자가 스크롤 할 때 고정 위치를 가진 요소가 움직이지 않는다는 것이다.

## float 속성으로 요소를 왼쪽 또는 오른쪽으로 민다.
* 플로팅 요소는 문서의 일반적인 흐름에서 제거되고 포함 된 상위 요소의 왼쪽이나 오른쪽으로 민다.
* float 요소에 필요한 수평 공간의 양을 지정하기 위해 일반적으로 width 속성과 함께 사용된다.

## z-index 속성을 사용하여 겹치는 요소의 위치 변경
* 요소가 겹치도록 배치될 때 HTML 마크업에서 나중에 나오는 요소는 기본적으로 다른 요소의 맨 위에 나타난다
* `z-index` 속성은 요소가 쌓이는 순서를 지정할 수 있다. 
* 값은 정수 이어야한다.
* 요소의 `z-index` 속성 값이 높을 수록 값이 낮은 것보다 스택에서 더 높게 이동한다.

## margin 속성을 사용하여 요소를 수평으로 가운데 맞추기 
* 블록 요소를 수평으로 중앙에 배치하는 한 가지 방법은 여백을 auto 값으로 설정하는 것이다.

## 보색에 대해 알아보기 
* 색상 이론과 디자인에 대한 영향은 깊은 주제이며 여기서는 기본 사항만 다룬다. 웹 사이트에서 색상은 콘텐츠에 주의를 끌거나 감정을 불러 일으키거나 시각적 조화를 이룰 수 있다. 서로 다른 색상 조합을 사용하면 웹 사이트의 모양이 실제로 변경 될 수 있으며 많은 생각이 내용과 함께 작동하는 색상 팔레트를 선택 할 수 있다. 
* 색상환은 색상이 서로 관련되는 방식을 시각화하는데 유용한 도구이다. 유사한 색상이 인접하고 다른 색상이 더 멀리있는 원이다. 휠에서 두 색상이 서로 반대되는 경우 이를 보색이라고 한다. 그들이 결합되면 서로를 "취소" 하고 회색을 만드는 특성을 가지고 있다. 그러나 나란히 배치하면 이러한 색상이 더욱 생동감있게 보이고 시각적 대비가 강해진다.
* 16진 코드가 있는 보색의 예는 다음과 같다
```
빨간색 #ff0000 <-> 녹청색 #00ffff
녹색 #00ff00 <-> 자홍색 #ff00ff
파란색 #0000ff <-> 노란색 #ffff00
```
* 이것은 우리 중 많은 사람들이 학교에서 가르치는 오래된 RYB 색상 모델과는 다른 기본 색상과 보색이 다르다. 현대의 색상 이론은 컴퓨터 화면과 같은 추가 RGB 모델과 인쇄와 같은 감산 CMY(K) 모델을 사용한다. 이 복잡한 주제에 대한 자세한 내용은 [여기](https://en.wikipedia.org/wiki/Color_model)를 읽어보자.
* 온라인에서 사용 가능한 많은 색상 선택 도구를 사용하여 색상의 보완을 찾을 수 있다.
* 참고: 모든 색상 문제: 색상을 사용하면 페이지에 시각적인 흥미를 더할 수 있습니다. 그러나 시각 장애가 있는 사용자는 해당 내용을 이해하지 못할 수 있으므로 중요한 정보를 전달하는 유일한 방법으로 색상만 사용만 사용해서는 안된다.

## 3 차 색상에 대해 알아보기
* 컴퓨터 모니터와 디바이스 화면은 빨강, 녹색, 파랑 빛을 결합하여 다른 색상을 만듭니다. 이것은 현대 색상 이론에서 RGB 추가 색상 모델로 알려져 있습니다. red (R), green (G), blue (B) 을 기본 색상이라고 합니다. 두 가지 기본 색상을 혼합하면 cyan;청록색 (G + B), magenta;자홍색 (R + B), yellow;노란색 (R + G) 의 보조 색상이 생성 됩니다. 보색 알아보기에서 이 색상들을 보았습니다. 이러한 2차 색상은 생성시 사용되지 않은 1차 색상을 보완하며 색상환의 기본 색상과 반대입니다. 예를 들어 magenta;자홍색은 빨간색과 파란색으로 만들어지며 녹색을 보완합니다. 
* 3차 색상은 1차 색상을 2차 색상 이웃 중 하나와 결합한 결과입니다. 예를들어, RGB 색상 모델 내에서 빨강(1차) 및 노랑(2차)은 주황색(3차)가 됩니다. 이로 인해 총 12개의 컬러 휠에 6가지 색상이 추가됩니다. 
* 다양한 색상을 선택하는 방법이 디자인에서 조화를 이루도록 합니다. 3차 색상을 사용 할 수 있는 한 예를 분할 보완 색상 구성표라고 합니다. 이 구성표는 기본 색상으로 시작한 다음 보색에 인접한 두 색상과 쌍을 이룹니다. 세 가지 색상은 디자인에서 시각적으로 강한 대비를 제공하지만 두 가지 보완 색상을 사용하는 것보다 미묘합니다. 
* 분할 보완 구성표를 사용하여 만든 세 가지 색상은 다음과 같습니다.

|Color| Hex Code
------|---------
|orange|#ff7f00
|cyan|#00ffff
|raspberry|#ff007f

## 다양한 요소의 색상을 보완 색상으로 조정
* 보완 색상 문제는 컬러 휠의 반대 색상으로 나란히 할 때 서로 더 생생하여 보일 수 있음을 보여주었습니다. 그러나 웹 사이트에서 지나치게 많이 사용하면 시각적으로 강한 대비가 어려워 질 수 있으며 보완적인 배경에 텍스트를 배치하면 텍스트를 읽기가 더 어려워 질 수 있습니다. 실제로, 색상 중 하나가 주로 지배적이며 보완은 페이지의 특정 내용에 시각적인 주의를 끌기 위해 사용됩니다. 

## 색상의 색조 조정 
* 색상에는 색조, 채도 및 명도를 비롯한 여러가지 특성이 있습니다. CSS3에서는 이러한 특성을 직접 지정하여 색상을 선택하는 대체 방법으로 hsl() 속성을 도입했습니다.
* __Hue__; 색조는 사람들이 일반적으로 `색상`으로 생각하는 것입니다. 왼쪽에서 빨간색으로 시작하여 가운데에서 녹색으로 이동하고 오른쪽에서 파란색으로 이동하는 색상의 스펙트럼을 그리는 경우 색조는 이 선을 따라 색상이 맞는 곳입니다. hal()에서 색상은 스펙트럼 대신 색상환 개념을 사용합니다. 원의 각도에서 0에서 360사이의 값으로 제공됩니다. 
* __Saturation__; 채도는 색상에서 회색의 양입니다. 완전 채색 된 색상에는 회색이 없고 최소 채도 색상은 거의 완전히 회색입니다. 이것은 100% 완전 포화 상태의 백분율로 제공됩니다. 
*__Lightness__; 명도는 색상에서 흰색 또는 검은색의 양입니다. 0% (검은색)에서 100% (흰색) 까지의 백분율이 제공되며 여기서 50%는 일반 색상입니다. 
* 다음은 완전 포화 된 일반 명도 색상으로 hsl()을 사용하는 몇 가지 예입니다.

|Color|HSL
-----|---
red|hsl(0, 100%, 50%)
yellow|hsl(60, 100%, 50%)
green|hsl(120, 100%, 50%)
cyan|hsl(180, 100%, 50%)
blue|hsl(240, 100%, 50%)
magenta|hsl(300, 100%, 50%)

## 색상 톤 조정
* CSS의 hsl() 옵션을 사용하면 색상 톤을 쉽게 조정 할 수 있습니다. 흰색과 순수한 색조를 혼합하면 해당 색조의 색조가 생성되고 검은 색을 추가하면 음영이 만들어집니다. 또는 회색을 추가하거나 색조와 음영을 모두 사용하여 톤을 만듭니다. hsl()의 `s`와 `l`은 각각 채도와 밝기를 나타냅니다. 채도 백분율은 회색의 양을 변경하고 밝기 박분율은 색상의 흰색 또는 검정색의 양을 결정합니다. 기본 색조가 마음에 들지만 다른 변형이 필요한 경우에 유용합니다. 

## 점진적 CSS 선형 그라디언트 만들기 
* HTML 요소에 색상을 적용하는 것은 하나의 플랫 색조로 제한되지 않습니다. CSS 요소에 색상 전환(그라데이션이라고도 함)을 사용하는 기능을 제공합니다. 백그라운드 속성의 linear-gradient() 함수를 통해 엑세스 합니다. 일반적인 구문은 다음과 같습니다. 

```css
background: linear-gradient(gradient_direction, color 1, color 2, color 3, ...);
```

* 첫 번째 인수는 색상 전환이 시작되는 방향을 지정합니다. 90도는 세로 그라디언트를 만들고 45도는 백슬래시처럼 각을 이루는 각도로 표시 할 수 있습니다. 다음 인수는 그라디언트에 사용되는 색상의 순서를 지정합니다. 

예제:

```css
background: linear-gradient(90deg, red, yellow, rgb(204, 204, 255));
```

## CSS 선형 그라디언트를 사용하여 스트라이프 요소 만들기
* `repeating-linear-gradient()` 함수는 지정된 그라디언트 패턴을 반복한다는 큰 차이점을 제외하고는 `linear-gradient()`와 매우 유사합니다. `repeating-linear-gradient()`는 다양한 값을 허용하지만 간단하게 하기 위해 이 과제에서 각도 값과 색상 정지 값을 사용합니다. 
* 각도 값은 그라디언트의 방향입니다. 색상 정지 점은 전환이 발생하는 위치를 표시하는 폭 값과 같으며 백분율 또는 여러 픽셀로 제공됩니다.
* 다음 예에서 그라디언트는 0 픽셀에서 노란색으로 시작하여 시작에서 40 픽셀 떨어진 두 번째 파란색으로 혼합됩니다. 다음 색상 정지 점도 40 픽셀이므로 그라디언트는 즉시 세 번째 녹색으로 변경되며 그라디언트 자체는 그라디언트의 시작에서 80픽셀 떨어진 네번째 색상 값 빨강으로 혼합됩니다. 
```css
div {
  background: repeating-linear-gradient(
    90deg,
    yellow 0px,
    blue 40px,
    green 40px,
    red 80px
  );
}
```
* 이 예에서는 색상 정지 점을 두 색상마다 혼합되는 쌍으로 생각하는데 도움이 됩니다.
```
- 0px [yellow -- blend -- blue]
- 40px [green -- blend -- red]
- 80px [green -- blend -- red]
```
* 두 가지 색상 정지 값이 모두 같은 색상이면 혼합이 같은 색상 사이에 있고 다음 색상으로의 하드 전환으로 인해 눈에 띄지 않으므로 줄무늬가 생깁니다. 

## 미묘한 패턴을 배경 이미지로 추가하여 텍스처 생성
* 배경에 질감과 관심을 더하고 눈에 띄게하는 한 가지 방법은 미묘한 패턴을 추가하는 것입니다. 중요한 것은 배경이 너무 눈에 띄지 않게 하고 전경에서 멀어지를 원하지 않기 때문에 균형입니다. background 속성은 선택한 텍스처 또는 패턴의 이미지에 연결하기 위해 url() 함수를 지원합니다. 링크 주소는 괄호 안에 따옴표로 묶습니다. 

```css
body {
  background: url("SUBTLE_PATTERN_URL")
}
```

## CSS 변환 축척 속성을 사용하여 요소의 크기 변경
* 요소의 크기를 변경하기 위해 CSS에는 scale() 함수와 함께 `transform` 속성이 있습니다. 다음 코드 예제는 페이지의 모든 단락 요소 크기를 두 배로 늘립니다.

```css
p {
  transform: scale(2);
}
```

## CSS 변환 축척 속성을 사용하여 호버에서 요소 축척
* 변형 속성에는 요소의 크기 조절(scale), 이동(move), 회전(rotate), 기울이기(skew) 등을 할 수 있는 다양한 기능이 있습니다. 요소의 특정 상태를 지정하는 `:hover` 와 같은 의사 클래스와 함께 사용하면 변환 속성이 요소에 대화형 기능을 쉽게 추가 할 수 있습니다.
* 다음은 사용자가 마우스를 가리킬 때 단락 요소를 원래 크기의 2.1배로 조정하는 예 입니다.
```css
p:hover {
  transform: scale(2.1);
}
```

## CSS 변환 속성 skewX 를 사용하여 X축을 따라 요소 기울이기 
* 변형 속성의 다음 함수는 `skewX()` 로 선택한 요소를 X(수평)축을 따라 지정된 각도만큼 기울입니다. 다음 코드는 단락 요소를 X축을 따라 -32도 기울입니다.
```css
p {
  transform: skewX(-32deg);
}
```

## CSS 변형 속성 skewY 를 사용하여 Y축을 따라 요소 기울이기
* `skewX()` 함수가 X축을 따라 선택한 요소를 주어진 각도만큼 기울이기 때문에 `skewY()` 함수는 Y(수직)축을 따라 요소를 기울이는 것은 놀라운 일이 아닙니다.

## CSS를 사용하여 그래픽 만들기
* 다른 선택기 및 속성을 조작하여 흥미로운 모양을 만들 수 있습니다. 가장 쉬운 방법 중 하나는 초승달 모양입니다. 이 문제를 해결하려면 요소 모서리를 둥글게하는 `border-radius` 속성과 함께 요소의 그림자를 설정하는 `box-shadow` 속성을 사용 해야합니다. 
* 측면에 약간 상쇄 된 선명한 그림자가 있는 둥글고 투명한 개체를 만듭니다. 그림자는 실제로 보이는 달 모양이 됩니다.
* 둥근 개체를 만들려면 `border-radius` 속성을 50%로 설정해야합니다. 
* `box-shadow` 속성은 offset-x, offset-y, blur-radius, spread-radius 및 color 값의 순서대로 값을 취합니다. `blur-radius` 및 `spread-radius` 값은 선택 사항 입니다. 

```css
.moon {
  background-color: transparent;
  border-radius: 50%;
  box-shadow: 25px 10px 0 0 blue;
}
```

## CSS와 HTML을 사용하여 더 복잡한 모양 만들기
* 세계에서 가장 인기 있는 도형 중 하나는 하트 모양이며, 이 도전에서 순수한 CSS를 사용하여 만듭니다. 그러나 먼저, 의사 요소 `::before` 와 `::after`를 이해해야합니다. 이 의사 요소는 선택한 요소의 앞이나 뒤에 무언가를 추가하는데 사용 됩니다. 다음 예제에서는 `::before` pseudo-element 를 사용하여 클래스 heart 를 가진 요소에 사각형을 추가합니다.
```css
.heart::before {
  content: "";
  background-color: yellow;
  border-radius: 25%;
  position: absolute;
  height: 50px;
  width: 70px;
  top: -50px;
  left: 5px;
}
```

* `::before` 및 `::after` pseudo-element 가 제대로 작동하려면 `content` 속성이 정의되어야 합니다. 이 속성은 일반적으로 선택한 요소에 사진 또는 텍스트 같은 것을 추가하는 데 사용됩니다. `::before` 및 `::after` pseudo-element 를 사용하여 모양을 만드는 경우 `content` 속성은 여전히 필요하지만 빈 문자열로 설정됩니다. 위의 예에서 심장 클래스를 가진 요소는 높이와 너비 각각 50px 70px인 노란색 사각형을 생성하는 `::before` pseudo-element 를 갖습니다. 이 사각형은 25% 테두리 반경으로 인해 둥근 모서리를 가지며 왼쪽에서 5px, 요소 상단에서 50px 위에 위치합니다. 

```css
.heart {
  position: absolute;
  margin: auto;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: pink;
  height: 50px;
  width: 50px;
  transform: rotate(-45deg);
}
.heart::after {
  background-color: pink;
  content: "";
  border-radius: 50%;
  position: absolute;
  width: 50px;
  height: 50px;
  top: 0px;
  left: 25px;
}
.heart::before {
  content: '';
  background-color: pink;
  border-radius: 50%;
  position: absolute;
  width: 50px;
  height: 50px;
  top: -25px;
  left: 0px;
}
```


